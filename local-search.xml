<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DOJ 608 字典序最小(单调栈)</title>
    <link href="/2022/03/21/doj608/"/>
    <url>/2022/03/21/doj608/</url>
    
    <content type="html"><![CDATA[<h4 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a><a href="http://oj.daimayuan.top/problem/608">原题链接</a></h4><p>从序列 $M$ 个数中顺序选出 $N$个不同的数, 使得这 $N$个数的字典序最小。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数 $M$, $N$分别表示序列长度，顺序选取数据的个数 (其中$1&lt;N\leq M \leq 10^6$）。</p><p>接下来$M$行，第$i$输入为$a_i$，表示序列$M$中第$i$个数，其中$1\leq a_i \leq N$，数据保证 $[1,N]$范围内每个数至少出现一次。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出$N$个数, 用空格隔开, 表示最小字典序 （最后一个输出不能有多余空格）。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">3</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h4><p>求解的最小字典序不必在序列$M$中连续。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为要顺序取，考虑单调栈，在维护出现顺序的同时要求字典序尽可能小。<br>所以小的数应该尽可能放在前面，大的数要尽可能放在后面。<br>扫描每一个数a：<br>1.如果a已经在栈里，就continue。<br>2.如果栈顶的元素b如果比a大，且b有机会在后面再进栈的话，那就暂时弹出b。<br>3.重复操作，直到栈空或者栈顶小于a，在压入a。<br>这样就在维护出现顺序的同时，也保证了字典序最小。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, a[<span class="hljs-number">1000010</span>], b[<span class="hljs-number">1000010</span>], s[<span class="hljs-number">1000010</span>], in[<span class="hljs-number">1000010</span>], top = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++) cin &gt;&gt; a[i], b[a[i]] = i;<span class="hljs-comment">//记录一下每个数最后出现的下标</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(in[a[i]]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">while</span>(top != <span class="hljs-number">-1</span> &amp;&amp; s[top] &gt;= a[i] &amp;&amp; b[s[top]] &gt;= i)<br>    <span class="hljs-comment">//栈不空，栈顶大于现在这个数，栈顶在后面还能加进来</span><br>    in[s[top --]] = <span class="hljs-number">0</span>;<br>    s[++ top] = a[i], in[a[i]] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i ++) cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; s[top];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P3953 逛公园(小于等于最短路径+k的路径计数)</title>
    <link href="/2022/03/19/luogup3953/"/>
    <url>/2022/03/19/luogup3953/</url>
    
    <content type="html"><![CDATA[<h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a><a href="https://www.luogu.com.cn/problem/P3953">原题链接</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>​        一个有向图，$N$个点，$M$条边，无自环、重边和负权边，设起点$1$到终点$N$的最短路长度是$d$，求起点到终点路径长度为$d\to d+k$的路径数之和对$P$取模，如果有无穷路径，输出$-1$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        ①求最短路，考虑到$T\leq5,N\leq10^5,M\leq2\times10^5$，使用堆优化$Dijkstra$或者$spfa$，记录从起点到每个点的最短路长度。</p><p>​        ②$K\leq50$，我们要得到所有的$K$的状态，考虑$DP$，当前我们走到的点是$cur$，<strong>到终点的最短路</strong>是$dist[cur]$，此时比最短路多走了$more$步的方案数是$dp[cur][more]$。</p><p>​        考虑所有点$cur$，$cur$到$next$一条有向边，边权为$w$，从$next$到终点多走的冗余长度是$nextmore$，那么从点$cur$经过边$w$，再从$next$到达终点的冗余长度为$more$，有</p><p>$dist[cur] + more &#x3D; dist[next] + nextmore + w$</p><p>$more&#x3D;dist[next]+nextmore+w-dist[cur]$</p><p>$nextmore &#x3D; more - (dist[next] + w - dist[cur])$</p><p>​        可以发现如果我们确定了一个$cur$，我们就可以从$next$转移过来了。</p><p>$$dp[cur][more] +&#x3D; dp[next][more - (dist[next] + w -dist[cur])]$$</p><p>​        ③$DP$ 状态计算：</p><p>​        根据三角不等式$dist[cur] \leq dist[next] + w$和$nextmore &#x3D; more - (dist[next] + w -dist[cur])$，我们可以确定$nextmore \leq more$，而我们需要从$next$转移到$cur$，为了确保我们计算用到的都是确定的已知的量，所以$K$需要从小到大枚举，<del>又因为某些点可能走不到终点</del>，因为我们求的$dist$数组是起点$1$开始的最短路，但是我们上面写的转移是指的到<strong>终点$N$的最短路</strong>(所以上面的<strong>三角不等式</strong>成立，因为求到终点最短路需要反向求，所以边也反向了)，所以反向建图，从终点$N$开始$DFS$记忆化搜索。（也可以反向求最短路，然后正向DFS<a href="https://www.acwing.com/solution/content/5484/">墨染空的题解</a>）</p><p>​        ④判断$0$环：</p><p>​        记忆化搜索的时候，如果搜到了自己，就表示有一个环，上面所有的边都是$0$。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>​        ①可能$0$环在起点处，所以搜到起点的时候不能直接返回，也得判断。</p><p>​        ②$dp$数组初始化为$-1$，就可以判断走没走过了，不用额外开数组判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200020</span>, K = <span class="hljs-number">51</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, k, p;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> H[N], E[M], NE[M], W[M], IDX;<span class="hljs-comment">//反向建图，用于后面记忆化搜索</span><br><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">//到起点的最短距离</span><br><span class="hljs-type">bool</span> st[N], vis[N][K];<br><span class="hljs-type">int</span> dp[N][K];<span class="hljs-comment">//比最短路径多k长度的路径数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">V</span>&#123;<span class="hljs-comment">//堆优化Dijkstra存点</span><br><span class="hljs-type">int</span> ver, dis;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> V &amp;a) <span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> dis &gt; a.dis;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span><span class="hljs-comment">//反向建图</span></span><br><span class="hljs-function"></span>&#123;<br>E[IDX] = b, W[IDX] = c, NE[IDX] = H[a], H[a] = IDX ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>priority_queue&lt;V&gt; heap;<br>heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())<br>&#123;<br><span class="hljs-keyword">auto</span> [u, d] = heap.<span class="hljs-built_in">top</span>(); <br>heap.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(st[u]) <span class="hljs-keyword">continue</span>;<br>st[u] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>&#123;<br><span class="hljs-type">int</span> v = e[i];<br><span class="hljs-keyword">if</span>(dist[v] &gt; d + w[i])<br>&#123;<br>dist[v] = dist[u] + w[i];<br>heap.<span class="hljs-built_in">push</span>(&#123;v, dist[v]&#125;);<br>&#125;<br>&#125; <br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span><span class="hljs-comment">//输入</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><span class="hljs-built_in">memset</span>(H, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> H);<br>idx = IDX = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>&#123;<br><span class="hljs-type">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><span class="hljs-built_in">add1</span>(a, b, c);<br>        <span class="hljs-built_in">add2</span>(b, a, c);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> more)</span><span class="hljs-comment">//cur表示到当前点，比最短路多走了more步</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    表示出现0环，什么意思呢？</span><br><span class="hljs-comment">    首先要知道，我们的nextmore一定是小于等于more的</span><br><span class="hljs-comment">    因为next到cur的那条边是非负权的，根据下面分析</span><br><span class="hljs-comment">    more = dist[next] + w - dist[cur] + nextmore</span><br><span class="hljs-comment">    根据三角不等式，如果next到cur有一条边w，那么dist[cur] &lt;= dist[next] + w</span><br><span class="hljs-comment">    （注意这里虽然是反向图，但是原来的大小关系还在，所以假定边不换方向，dist指的是到起点1距离）</span><br><span class="hljs-comment">    所以dist[next] + w - dist[cur] &gt;= 0</span><br><span class="hljs-comment">    所以nextmore = more - (dist[next] + w - dist[cur]) &lt;= more</span><br><span class="hljs-comment">    那么我们如果用正在被更新的东西更新他自己，就说明nextmore == more，w == 0</span><br><span class="hljs-comment">    即出现了一个0环,表示我们尝试用0环来更新最短路，那肯定能无限自己加自己变成无穷</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">if</span>(vis[cur][more])<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span>(~dp[cur][more]) <span class="hljs-keyword">return</span> dp[cur][more];<span class="hljs-comment">//记忆化搜索</span><br>dp[cur][more] = <span class="hljs-number">0</span>;<span class="hljs-comment">//走到这，标记一下，表示当前已经确定了</span><br>    <br><span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span> &amp;&amp; more == <span class="hljs-number">0</span>) dp[cur][more] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//走到起点了，注意我们这里不能return因为可能起点在0环上</span><br><br>vis[cur][more] = <span class="hljs-number">1</span>;<span class="hljs-comment">//打上标记</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = H[cur]; ~i; i = NE[i])<br>&#123;<br><span class="hljs-type">int</span> next = E[i];<span class="hljs-comment">//可以从next走到cur</span><br><span class="hljs-type">int</span> nextmore = dist[cur] - dist[next] + more - W[i];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">next-&gt;cur有一条w的边</span><br><span class="hljs-comment">到next多走了nextmore步，从w再走到cur，</span><br><span class="hljs-comment">那么就是到cur走了dist[next]+w+nextmore步</span><br><span class="hljs-comment">减去dist[cur]就是到cur多走的步数</span><br><span class="hljs-comment">more = dist[next] + w + nextmore - dist[cur]</span><br><span class="hljs-comment">nextmore = dist[cur] + more - dist[next] - w</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span>(nextmore &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//next多走了负数步，不合法</span><br><span class="hljs-type">int</span> val = <span class="hljs-built_in">dfs</span>(next, nextmore);<span class="hljs-comment">//next多走nextmore步的方案数</span><br><span class="hljs-keyword">if</span>(val == <span class="hljs-number">-1</span>)<br>&#123;<br>vis[cur][more] = <span class="hljs-number">0</span>;<span class="hljs-comment">//恢复原状</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//有一个返回-1，那么所有上一层的val都成了-1</span><br>&#125;<br>dp[cur][more] = (dp[cur][more] + val) % p;<br>&#125;<br>vis[cur][more] = <span class="hljs-number">0</span>;<span class="hljs-comment">//恢复原状，表示这一条已经整完了</span><br><span class="hljs-keyword">return</span> dp[cur][more];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> dp);<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i ++ )<span class="hljs-comment">//dp</span><br>&#123;<br><span class="hljs-type">int</span> val = <span class="hljs-built_in">dfs</span>(n, i);<span class="hljs-comment">//记忆化搜索</span><br><span class="hljs-keyword">if</span>(val == <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>res = (res + val) % p;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;<br>    <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">dijkstra</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">work</span>() &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOJ Daily Div2 207 01序列(前缀和)</title>
    <link href="/2022/03/11/DOJ-Daily-Div2-207-01%E5%BA%8F%E5%88%97/"/>
    <url>/2022/03/11/DOJ-Daily-Div2-207-01%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="01序列"><a href="#01序列" class="headerlink" title="01序列"></a>01序列</h2><p><a href="http://oj.daimayuan.top/course/11/problem/502">原题链接</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个$01$字符串，有多少子串中有$k$个$1$。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>前缀和</p><p>不需要特判且简单，感觉有点像dp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> k;<br><span class="hljs-type">char</span> s[<span class="hljs-number">1000010</span>];<br><span class="hljs-type">int</span> p[<span class="hljs-number">1000010</span>], c[<span class="hljs-number">1000010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; k &gt;&gt; s + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    p[i] = p[i - <span class="hljs-number">1</span>] + (s[i] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//p[r] - p[l - 1] == k</span><br>    <span class="hljs-comment">//p[r] == p[l - 1] + k</span><br>    <span class="hljs-comment">// l &lt;= r -&gt; (l - 1) &lt; r 所以l-1在r前面，所以每次加c[p[i - 1]]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        c[p[i - <span class="hljs-number">1</span>] + k] ++;<br>        ans += c[p[i]];<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>双指针，要特判，代码较麻烦。</p><p>开始想到前缀和，但是不知道怎么计算个数。原来可以用个数组记录一下当前需要的下标的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> k;<br><span class="hljs-type">char</span> s[<span class="hljs-number">1000010</span>];<br><span class="hljs-type">int</span> c[<span class="hljs-number">1000010</span>], m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; k &gt;&gt; s + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) c[m ++] = i;<br><br>    <span class="hljs-keyword">if</span>(m &lt; k)&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>    <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>    ans += (i - last - <span class="hljs-number">1</span>) * (i - last) / <span class="hljs-number">2</span>;<br>    last = i;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s[n] == <span class="hljs-string">&#x27;0&#x27;</span>) ans += (n - last) * (n - last + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l = <span class="hljs-number">0</span>, r = k - <span class="hljs-number">1</span>; r &lt; m; l ++, r ++)&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> cl, cr;<br>    <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>) cl = c[l];<br>    <span class="hljs-keyword">else</span> cl = c[l] - c[l - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span>(r == m - <span class="hljs-number">1</span>) cr = n + <span class="hljs-number">1</span> - c[r];<br>    <span class="hljs-keyword">else</span> cr = c[r + <span class="hljs-number">1</span>] - c[r];<br>    ans += cl * cr;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯第十二届省赛C/C++B组题解</title>
    <link href="/2022/03/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%9C%81%E8%B5%9BCB%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%9C%81%E8%B5%9BCB%E7%BB%84%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯第十二届省赛C-x2F-C-B组题解"><a href="#蓝桥杯第十二届省赛C-x2F-C-B组题解" class="headerlink" title="蓝桥杯第十二届省赛C&#x2F;C++B组题解"></a>蓝桥杯第十二届省赛C&#x2F;C++B组题解</h1><p><a href="https://www.lanqiao.cn/courses/2786/learning/?id=280826">原题链接</a></p><h2 id="A-空间"><a href="#A-空间" class="headerlink" title="A.空间"></a>A.空间</h2><p> 常识题：1字节&#x3D;$8bit$，32位int占4字节。</p><p>$1GB&#x3D;2^{10}MB&#x3D;2^{20}KB&#x3D;2^{30}Byte&#x3D;2^{30}*8bit$</p><p>$256MB&#x3D;2562^{10}KB&#x3D;256\times2^{20}B&#x3D;256\times2^{20}\times8bit&#x3D;2^{31}bit$</p><p>$ans&#x3D;2^{31}bit\div32bit&#x3D;67108864$</p><p>答案：67108864</p><h2 id="B-卡片"><a href="#B-卡片" class="headerlink" title="B.卡片"></a>B.卡片</h2><p>​        数值较小，直接暴力模拟每一位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//暴力计数 </span><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>string s = <span class="hljs-built_in">to_string</span>(i);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s)&#123;<br><span class="hljs-keyword">if</span>(a[c - <span class="hljs-string">&#x27;0&#x27;</span>] -- == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++) a[i] = <span class="hljs-number">2021</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; ; i ++)<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(i))&#123;<br>cout &lt;&lt; i - <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案：3181</p><h2 id="C-直线"><a href="#C-直线" class="headerlink" title="C.直线"></a>C.直线</h2><p>​        两点确定一条直线问题，数据较小，直接两两暴力枚举。</p><p>一条直线由两个属性确定：斜率和截距。我们可以通过找到所有的斜率$k$和截距$d$的组合，就可以得到直线数量。</p><p>注意：</p><p>​        1.$double$有精度问题。</p><p>​        2.我们的斜率一律不考虑无穷和0的情况。最后在答案再加上即可。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​        如果两个类型为$double$的浮点数相减的绝对值$\le 1e^{-8}$， 那么我们可以认为这两个数相等。所以我们可以把所有得到的直线$pair(k,d)$进行排序，如果相邻的直线的$k$和$d$可以认为相等，那么总数就$-1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; PDD;<br>vector&lt;PDD&gt; lines;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">21</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>; x1 &lt; a; x1 ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y1 = <span class="hljs-number">0</span>; y1 &lt; b; y1 ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x2 = <span class="hljs-number">0</span>; x2 &lt; a; x2 ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y2 = <span class="hljs-number">0</span>; y2 &lt; b; y2 ++)&#123;<br><span class="hljs-keyword">if</span>(x1 == x2 || y1 == y2) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">int</span> dx = x2 - x1, dy = y2 - y1;<br><span class="hljs-type">double</span> k = (<span class="hljs-type">double</span>)dy / dx;<br>PDD line = &#123;k, y1 - k*x1&#125;;<br>lines.<span class="hljs-built_in">push_back</span>(line);<br>&#125;<br><br><span class="hljs-built_in">sort</span>(lines.<span class="hljs-built_in">begin</span>(), lines.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-type">int</span> ans = lines.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-type">int</span>)lines.<span class="hljs-built_in">size</span>(); i ++)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(lines[i].x - lines[i - <span class="hljs-number">1</span>].x) &lt; <span class="hljs-number">1e-8</span> &amp;&amp; <span class="hljs-built_in">fabs</span>(lines[i].y - lines[i - <span class="hljs-number">1</span>].y) &lt; <span class="hljs-number">1e-8</span>)<br>ans --;<br><br><span class="hljs-comment">// int ans = 1;</span><br><span class="hljs-comment">// for(int i = 1; i &lt; (int)lines.size(); i ++)</span><br><span class="hljs-comment">// if(fabs(lines[i].x - lines[i - 1].x) &gt; 1e-8 || fabs(lines[i].y - lines[i - 1].y) &gt; 1e-8)</span><br><span class="hljs-comment">// ans ++;</span><br><br>cout &lt;&lt; ans + a + b &lt;&lt; endl;<span class="hljs-comment">//因为之前没有加上与坐标轴平行的直线</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​        我们存斜率的时候，不用$double$来存，而是用最简分式$dy&#x2F;dx$来表示，这个$dy$和$dx$都是整数，可以通过两点$dy_1-dy_2&#x2F;dx_1-dx_2$化简表示，化简方式是上下同除以最大公因数。用一个$map$来存一个$vector$，$vector$来保存斜率相同，但是截距不同的直线上的一个点，因为在同样的斜率下，只要知道一个点的坐标就可以确定一条直线。在向$vector$中加入点的时候，我们只需要遍历一下这个$vector$，确定一下里面有没有点跟想要加入的点在同一条直线上，如果没有，就加进去。最后只需要遍历所有斜率，把$vector$的$size$求和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br>map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; m;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; a, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; k)</span></span>&#123;<br><span class="hljs-type">int</span> kx = k.x, ky = k.y;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b : m[k]) &#123;<br><span class="hljs-keyword">if</span>(kx * (b.y - a.y) == ky * (b.x - a.x)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>; x1 &lt; a; x1 ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y1 = <span class="hljs-number">0</span>; y1 &lt; b; y1 ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x2 = <span class="hljs-number">0</span>; x2 &lt; a; x2 ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y2 = <span class="hljs-number">0</span>; y2 &lt; b; y2 ++)&#123;<br><span class="hljs-keyword">if</span>(x1 == x2 || y1 == y2) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">int</span> dx = x2 - x1, dy = y2 - y1;<br><span class="hljs-type">int</span> g = <span class="hljs-built_in">gcd</span>(dx, dy);<br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; k = &#123;dx / g, dy / g&#125;;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(&#123;x1, y1&#125;, k)) m[k].<span class="hljs-built_in">insert</span>(&#123;x1, y1&#125;);<br>&#125;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t : m) ans += (t.y).<span class="hljs-built_in">size</span>();<br><br>cout &lt;&lt; ans + a + b &lt;&lt; endl;<span class="hljs-comment">//40257</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案：40257</p><h2 id="D-货物摆放"><a href="#D-货物摆放" class="headerlink" title="D.货物摆放"></a>D.货物摆放</h2><p>​        给出$n&#x3D;2021041820210418$，计算有多少种赋值方案，使$L\times W\times H&#x3D;n$，且数都是正整数，两两无关。</p><p>因为两两无关，所以 $1\times1\times2&#x3D;2$ 和 $1\times2\times1&#x3D;2$ 是两种不同的方案。</p><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><p>​        $n$很大，三个数显然是由$n$的某个因数，更进一步，三个数一定是由$n$的某些质因子相乘组成。</p><p>所以我们尝试分解质因子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span></span>&#123;<span class="hljs-comment">//分解质因数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)&#123;<br><span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>) n /= i, cnt ++;<br>primes.<span class="hljs-built_in">push_back</span>(i);<br>c[i] = cnt;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) primes.<span class="hljs-built_in">push_back</span>(n), c[n] = <span class="hljs-number">1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们得到质因子有：2，3，3，3，17 ，131，2857 ，5882353共八个。</p><p>所以需要把这八个数分配给L，W和H。</p><p>因为有3个3，所以可以先分配3，有10种方案：</p><p>003 030 300 120 102 210 201 012 021 111</p><p>剩下五个数有3^5种方案。</p><p>相乘就是答案。</p><h3 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h3><p>先把$n$的所有因数拿出来，L，W，M必然是$n$的某一个因数。三重循环暴力找即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>vector&lt;LL&gt; p;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(LL n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i ++)&#123;<br>        <span class="hljs-comment">//注意这里不要漏了1</span><br><span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(n / i != i) p.<span class="hljs-built_in">push_back</span>(n / i);<br>p.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>LL n = <span class="hljs-number">2021041820210418</span>;<br><br><span class="hljs-built_in">init</span>(n);<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : p)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b : p)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : p)<br><span class="hljs-keyword">if</span>(a * b * c == n) ans ++;<br><br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案：2430</p><h2 id="E-路径"><a href="#E-路径" class="headerlink" title="E.路径"></a>E.路径</h2><p>考察两点：</p><p>​        1.$gcd$和$lcm$： $lcm &#x3D; a * b &#x2F; gcd(a, b)$</p><p>​        2.单源最短路：Dijkstra，spfa，Floyd，bellman_ford都可以</p><h3 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h3><p>​        Floyd，$O(n^3)$大概要跑20s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> g[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> b? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a * b / <span class="hljs-built_in">gcd</span>(a, b);<br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">21</span>; j ++)&#123;<br><span class="hljs-keyword">if</span>(i + j &lt;= <span class="hljs-number">2021</span>)&#123;<br>g[i][i + j] = g[i + j][i] = <span class="hljs-built_in">lcm</span>(i, i + j);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">2021</span>; k ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j ++)<br>g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], g[i][k] + g[k][j]);<br><br>cout &lt;&lt; g[<span class="hljs-number">1</span>][<span class="hljs-number">2021</span>] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h3><p>​        $Dijkstra$ 复杂度 $O(n^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dist[<span class="hljs-number">2022</span>], vis[<span class="hljs-number">2022</span>];<br><span class="hljs-type">int</span> n = <span class="hljs-number">2021</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br><span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) t = j;<br><br>vis[t] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(t == n) <span class="hljs-keyword">return</span> dist[t];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>&#125;<br><span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>​        $bellmanford$ 复杂度$O(n*m)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[i] + g[i][j]);<br><span class="hljs-keyword">return</span> dist[n];<br><span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>​        $spfa$ 复杂度一般$O(m)$，最坏$O(n*m)$</p><p>​        要用邻接表构图，这里就不写了。</p><p>答案：10266837</p><h2 id="F-时间显示"><a href="#F-时间显示" class="headerlink" title="F.时间显示"></a>F.时间显示</h2><p>​        只关心时分秒，不关心天数。算出天，小时，分钟，秒对应多少毫秒，一步步除以后再取模即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> s = <span class="hljs-number">1</span>, m = s * <span class="hljs-number">60</span>, h = m * <span class="hljs-number">60</span>, d = h * <span class="hljs-number">24</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> t;<br>cin &gt;&gt; t;<br>t /= <span class="hljs-number">1000</span>;<br>t %= d;<span class="hljs-comment">//ms left in a day</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02lld:&quot;</span>, t / h);<br>t %= h;<span class="hljs-comment">//ms left in a hour</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02lld:&quot;</span>, t / m);<br>t %= m;<span class="hljs-comment">//ms left in a minite</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02lld\n&quot;</span>, t);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="G-砝码称重"><a href="#G-砝码称重" class="headerlink" title="G.砝码称重"></a>G.砝码称重</h2><h3 id="方法一-3"><a href="#方法一-3" class="headerlink" title="方法一"></a>方法一</h3><p>​        01背包问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">105</span>], n, m;<br><span class="hljs-type">bool</span> f[<span class="hljs-number">105</span>][<span class="hljs-number">200005</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> D = <span class="hljs-number">100000</span>;<span class="hljs-comment">//偏移量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i], m += w[i];<br><span class="hljs-comment">//m是能够得到最大的重量，即所有全加或者减去 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设物品放在左边</span><br><span class="hljs-comment">那么物品的重量=右边砝码的重量减去左边砝码的重量</span><br><span class="hljs-comment">所以我们可以最多可以选n个砝码，可以加也可以减</span><br><span class="hljs-comment">f[i][j]表示在前i个砝码里面选，能不能得到j重量</span><br><span class="hljs-comment">假设当前的砝码重量是w，有三种情况：</span><br><span class="hljs-comment">1.这个不选，flag1 = f[i - 1][j] </span><br><span class="hljs-comment">2.加上w，flag2 = f[i - 1][j + w]</span><br><span class="hljs-comment">3.减去w，flag3 = f[i - 1][j - w] </span><br><span class="hljs-comment">f[i][j] = flag1 | flag 2 | flag3;</span><br><span class="hljs-comment">*/</span> <br>f[<span class="hljs-number">0</span>][D] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = -m + D; j &lt;= m + D; j ++)<br>&#123;<br>f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">if</span>(j - w[i] &gt;= -m + D) f[i][j] |= f[i - <span class="hljs-number">1</span>][j - w[i]];<br><span class="hljs-keyword">if</span>(j + w[i] &lt;= m + D) f[i][j] |= f[i - <span class="hljs-number">1</span>][j + w[i]];<br>&#125;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = D + <span class="hljs-number">1</span>; j &lt;= m + D; j ++) <span class="hljs-keyword">if</span>(f[n][j]) ans ++;<br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二-3"><a href="#方法二-3" class="headerlink" title="方法二"></a>方法二</h3><p>​        两遍01背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">105</span>], n, m;<br><span class="hljs-type">bool</span> f[<span class="hljs-number">200005</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> D = <span class="hljs-number">100000</span>;<span class="hljs-comment">//偏移量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    cin &gt;&gt; n;<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i], m += w[i];<br>    <br>    <span class="hljs-comment">//跑两边01背包 先加后减</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= w[i]; j --)<br>            f[j] |= f[j - w[i]];<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m - w[i]; j ++)<br>        &#123;<br>            f[j] |= f[j + w[i]];<br>        &#125;<br>        <br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) <span class="hljs-keyword">if</span>(f[j]) ans ++;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="方法三-1"><a href="#方法三-1" class="headerlink" title="方法三"></a>方法三</h3><p>​        bitset<br>参考： <a href="https://www.acwing.com/solution/content/45929/">AcWing 3417. 蓝桥杯_2021省赛第一场_砝码称重 </a><br>其实就是方法二的bitset版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, w[<span class="hljs-number">101</span>];<br>bitset&lt;100001&gt; s;<span class="hljs-comment">//s[i]=1表示重量为i的可以表示</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];<br>    <br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-comment">//先把所有正的情况表示出来，或运算确保之前的结果保留下来（&gt;100010都被截取掉了）</span><br>    <span class="hljs-comment">//为什么不把负的先整出来，因为小于0的全部被截取掉了</span><br>        s |= s &lt;&lt; w[i];<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    不重：</span><br><span class="hljs-comment">    此时s里记录了所有砝码放到一边的时候能够表示的结果总数</span><br><span class="hljs-comment">    如题目样例，此时s中 0,1,4,5,6,7,10,11的值都是1</span><br><span class="hljs-comment">    此时把s右移w位，对于之前得到的结果中包含w的，右移w位得到的结果里面包含了之前算过的结果</span><br><span class="hljs-comment">    如w=4,则4,5,10,11中都包含了4,那么右移后变成0,1,6,11,这些位本来就是1,所以取或并不会重复</span><br><span class="hljs-comment">    而对于剩下的0,1,6,7本来里面没有4,那么右移就相当于-4,即-4,-3,2,3,取或后-4,-3被截断, 2,3位变成1,多了2种</span><br><span class="hljs-comment">    不漏：</span><br><span class="hljs-comment">    那有没有可能右移w的顺序不同会导致有些情况没找到呢？</span><br><span class="hljs-comment">    考虑到取或操作 (a | b) | c == (a | c) | b 具有交换律和结合律，所以不会有漏掉的情况 </span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    &quot;|=&quot;就是用来保证不重不漏</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        s |= s &gt;&gt; w[i];<br><br>    cout &lt;&lt; s.<span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span> &lt;&lt; endl;<span class="hljs-comment">//去掉0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="H-杨辉三角形"><a href="#H-杨辉三角形" class="headerlink" title="H.杨辉三角形"></a>H.杨辉三角形</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/03/10/111311_8c846416a0-QQ%E5%9B%BE%E7%89%8720220310204219.jpg"> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> N;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><span class="hljs-comment">// C(a, b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a, j = <span class="hljs-number">1</span>; j &lt;= b; i --, j ++)<br>res = res * i / j;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(m, k) &lt; N) l = m + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> r = m;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(l, k) != N) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; N;<br><span class="hljs-keyword">if</span>(N == <span class="hljs-number">1</span>)&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">16</span>; k &gt;= <span class="hljs-number">1</span>; k --) <span class="hljs-comment">//C(2k, k) ~ C(N, k)</span><br>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">bs</span>(k, <span class="hljs-number">2</span> * k, N);<br><span class="hljs-keyword">if</span>(ans != <span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//N in C(2k, k) ~ C(N, k) ?</span><br>cout &lt;&lt; <span class="hljs-number">1ll</span> * ans * (ans + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + k + <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="I-双向排序"><a href="#I-双向排序" class="headerlink" title="I.双向排序"></a>I.双向排序</h2><p>这我哪会啊<br>找规律+栈 &#x2F; Splay</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//找规律+栈</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span> &gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>PII stk[N];<br><span class="hljs-type">int</span> ans[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n, m, p, q;<br>cin &gt;&gt; n &gt;&gt; m;<br><br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(m --)&#123;<br>cin &gt;&gt; p &gt;&gt; q;<br><span class="hljs-keyword">if</span>(!p)&#123;<br><span class="hljs-keyword">while</span>(top &amp;&amp; stk[top].x == <span class="hljs-number">0</span>) <br>q = <span class="hljs-built_in">max</span>(q, stk[top --].y);<br><span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">2</span> &amp;&amp; stk[top - <span class="hljs-number">1</span>].y &lt;= q)<br>top -= <span class="hljs-number">2</span>;<br>stk[++ top] = &#123;<span class="hljs-number">0</span>, q&#125;;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(top)&#123; <span class="hljs-comment">//top==0&amp;&amp;p==1 is meaningless</span><br><span class="hljs-keyword">while</span>(top &amp;&amp; stk[top].x == <span class="hljs-number">1</span>) <br>q = <span class="hljs-built_in">min</span>(q, stk[top --].y);<br><span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">2</span> &amp;&amp; stk[top - <span class="hljs-number">1</span>].y &gt;= q)<br>top -= <span class="hljs-number">2</span>;<br>stk[++ top] = &#123;<span class="hljs-number">1</span>, q&#125;;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> k = n, l = <span class="hljs-number">1</span>, r = n;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= top; i ++)<br>&#123;<br><span class="hljs-keyword">if</span>(stk[i].x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">while</span>(r &gt; stk[i].y &amp;&amp; l &lt;= r)<br>ans[r --] = k --;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">while</span>(l &lt; stk[i].y &amp;&amp; l &lt;= r)<br>ans[l ++] = k --;<br><span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(top % <span class="hljs-number">2</span>)<br><span class="hljs-keyword">while</span>(l &lt;= r) ans[l ++] = k --;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">while</span>(l &lt;= r) ans[r --] = k --;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="J-括号序列"><a href="#J-括号序列" class="headerlink" title="J.括号序列"></a>J.括号序列</h2><p>见上一篇文章</p><p><a href="https://www.xia0nian.xyz/2022/03/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%9C%81%E8%B5%9BCB%E7%BB%84J%E9%A2%98-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%EF%BC%88dp%EF%BC%89/">括号序列</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯第十二届省赛CB组J题 括号序列（dp）</title>
    <link href="/2022/03/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%9C%81%E8%B5%9BCB%E7%BB%84J%E9%A2%98-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%EF%BC%88dp%EF%BC%89/"/>
    <url>/2022/03/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%9C%81%E8%B5%9BCB%E7%BB%84J%E9%A2%98-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%EF%BC%88dp%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a><a href="https://www.acwing.com/problem/content/3423/">原题链接</a></h2><img src="/2022/03/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%9C%81%E8%B5%9BCB%E7%BB%84J%E9%A2%98-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%EF%BC%88dp%EF%BC%89/problem.png" alt="problem"><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p><strong>关于状态表示的一些理解：</strong><br>$dp[i][j]$表示前i个括号，其中左括号比右括号最多多$j$个的方法数。<br>为什么第二维是这样设定的呢？<br>因为对于一个合法的括号序列，其任意一个前缀子序列中左括号的个数一定大于等于右括号的个数，<br>所以我们在求解过程中就要保证任意前缀子序列都是合法的。<br>题目要求我们加入最少的括号来使序列合法，所以我们最后要找到的是：<br><strong>①使整个括号序列合法<br>②且插入的括号数最少</strong> 的方案数。</p><p>所以我们最后遍历一遍$dp[length]$，<br>如果$dp[length][i] !&#x3D; 0$，<br>那么这就是能够使整个括号序列合法，且插入括号最少的方案数，<br><strong>（具体见代码中注释，包括了两种方法的联系和返回值的另一种写法）</strong><br>因为到最后右括号数目是定值，所以左括号比右括号多的越少，那么左括号就越少。</p><p><strong>实际上，这种dp表示方法是优化而来的：</strong><br>参考： <a href="https://www.acwing.com/solution/content/47526/">AcWing 3420. 括号序列</a><br>因为我们分两次分别计算添加左括号和右括号的方法数，在计算左括号时，我们只关心右括号，<br>所以我们的$dp[i][j]$可以表示直到第$i$个括号，我们一共添加了$j$个左括号，<br>那么我们必须保证添加$j$个左括号一定是合法的$(j&gt;&#x3D;add[i])$，$cnt[i]$表示直到第$i$个括号，前面最少要有多少个左括号才能使之合法。<br><strong>注意：这里的合法包括了左括号个数大于右括号的个数的情况</strong><br>如果这么做，我们就要预处理出add[i]数组。<strong>（对应下方方法三）</strong></p><p>然而，我们只是关心当前前缀序列是否合法，即：<br>$j+当前左括号个数-add[i]$<br>的值是否大于等于0，即加上<strong>某些个左括号</strong>之后左括号和右括号数量的差值是否大于等于0,<br>我们并不关心加上了多少个左括号。<br>所以不妨把$j$当成差值来进行表示，<br>上面解释过，因为到最后右括号数目是定值，所以左括号比右括号多的越少，那么左括号就越少。</p><p>至于为什么左括号和右括号可以分开算再相乘，y总和题解区的同学解释得很好，这里不再赘述。</p><p><strong>方法一：dp第一维表示到几个括号，第二维表示差值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[N][N];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-comment">//左括号 </span><br>&#123;<br><span class="hljs-comment">//dp[i][0] = dp[i - 1][-1] 不合法 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//右括号 </span><br>&#123;<br>dp[i][<span class="hljs-number">0</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % mod;<span class="hljs-comment">//不加左和加一个左 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>dp[i][j] = (dp[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>] + dp[i][j<span class="hljs-number">-1</span>]) % mod;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">dp[i][j] = dp[i-1][j+1]+dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][0]</span><br><span class="hljs-comment">解释： </span><br><span class="hljs-comment">dp[i-1][j+1]:</span><br><span class="hljs-comment">这一次我们加0个左,要满足左比右多j个</span><br><span class="hljs-comment">那么前i-1个括号就要满足左比右多j+1个(因为当前是右) </span><br><span class="hljs-comment">dp[i-1][j]:</span><br><span class="hljs-comment">同样的,这一次我们加1个左,那么前i-1个括号就要满足左比右多j个</span><br><span class="hljs-comment">.</span><br><span class="hljs-comment">.</span><br><span class="hljs-comment">.</span><br><span class="hljs-comment">dp[i-1][0]:</span><br><span class="hljs-comment">直到我们这一次加j个左,那么前i-1个括号就要满足j=0 </span><br><span class="hljs-comment">注意:</span><br><span class="hljs-comment">这样算我们的复杂度是n^3,会超时,考虑: </span><br><span class="hljs-comment">dp[i][j] = dp[i-1][j+1]+dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][0]</span><br><span class="hljs-comment">dp[i][j-1] =            dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][0]</span><br><span class="hljs-comment">所以:</span><br><span class="hljs-comment">dp[i][j] = dp[i-1][j+1] + dp[i][j-1];</span><br><span class="hljs-comment">*/</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br><span class="hljs-keyword">if</span>(dp[n][i])<br><span class="hljs-keyword">return</span> dp[n][i];<br>    <span class="hljs-comment">//这里的第二维就对应着 </span><br>    <span class="hljs-comment">//加上j个左括号后，左括号的总数减去右括号的总数</span><br>    <span class="hljs-comment">//我们利用方法3的思路，其实答案就是f[n][minl + cntl - cntr]</span><br>    <span class="hljs-comment">//minl表示加上最少多少个左括号整个序列就合法</span><br>    <span class="hljs-comment">//cntl和cntr表示原来左括号和右括号的数量</span><br>    <span class="hljs-comment">//所以我们也可以这么写：</span><br>    <span class="hljs-comment">// int minl = 0, cntl = 0, cntr = 0, cnt = 0;</span><br>    <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++)</span><br>    <span class="hljs-comment">// if(str[i] == &#x27;(&#x27;) cnt ++, cntl ++;</span><br>    <span class="hljs-comment">// else&#123;</span><br>    <span class="hljs-comment">//     cnt --;</span><br>    <span class="hljs-comment">//     cntr ++;</span><br>    <span class="hljs-comment">//     if(cnt &lt; 0) minl ++, cnt ++;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// return f[n][minl + cntl - cntr];</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin &gt;&gt; s + <span class="hljs-number">1</span>;<br>n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l, r;<br>l = <span class="hljs-built_in">sol</span>();<br><span class="hljs-built_in">reverse</span>(s + <span class="hljs-number">1</span>, s + n + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) s[i] = <span class="hljs-string">&#x27;)&#x27;</span>; <span class="hljs-keyword">else</span> s[i] = <span class="hljs-string">&#x27;(&#x27;</span>;<br>r = <span class="hljs-built_in">sol</span>();<br><br>cout &lt;&lt; r * l % mod &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>方法二：dp第一维表示到第几个右括号，第二维表示添加左括号的个数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">char</span> s[<span class="hljs-number">5003</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">5003</span>][<span class="hljs-number">5003</span>], add[<span class="hljs-number">5003</span>];<br><span class="hljs-comment">//f[i][j]表示对前i个右括号，我们添加j个左括号使其合法的方案数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Work</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, cntr = <span class="hljs-number">0</span>;<span class="hljs-comment">//cnt用的是y总方法记录是否需要加左括号；cntr记录右括号出现次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) cnt ++;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt --;<br>            cntr ++;<br>            add[cntr] = add[cntr - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(cnt &lt; <span class="hljs-number">0</span>) add[cntr] ++, cnt ++;<span class="hljs-comment">//add记录最少需要添加的左括号的数量</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// int minl = *max_element(add + 1, add + 1 + cntr); //整个右括号组成的序列需要添加的最少的左括号数量</span><br>    <span class="hljs-type">int</span> minl = add[cntr];<span class="hljs-comment">//显然add序列是严格单调不减的</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= cntr; i ++) f[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化</span><br>    <span class="hljs-comment">//没有右括号，那么无论加多少个左括号都只有一种方案（直到加到右括号总个数那么多，再多就没必要了）</span><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    状态计算：</span><br><span class="hljs-comment">    考虑f[i][j]从什么状态转移过来：</span><br><span class="hljs-comment">        这次加上0,1,2,3...j个左括号</span><br><span class="hljs-comment">    所以f[i][j] = f[i-1][j] + f[i-1][j-1] + f[i-1][j-2] + f[i-1][j-3] +...+ f[i-1][0]</span><br><span class="hljs-comment">    又有f[i][j-1] =           f[i-1][j-1] + f[i-1][j-2] + f[i-1][j-3] +...+ f[i-1][0]</span><br><span class="hljs-comment">    所以f[i][j] = f[i-1][j] + f[i][j-1];</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cntr; i ++)<span class="hljs-comment">//从左到右枚举右括号</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = add[i]; j &lt;= cntr; j ++) f[i][j] = (f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>]) % mod;<br>        <span class="hljs-comment">//j &lt; add[i]的时候都是0，不合法，大于等于add[i]直接根据推到的公式在转移</span><br>        <span class="hljs-comment">//另外可以发现，我们这里用到了f[i - 1][j]，所以i=0的状态我们要先初始化出来（见上面）</span><br><br>    <span class="hljs-keyword">return</span> f[cntr][minl]; <span class="hljs-comment">//表示对于前cntr个右括号（即所有右括号），我们添加minl个左括号使其合法的方案数</span><br>    <span class="hljs-comment">//①因为要满足添加的括号要最少，如果第二维大于minl，虽然合法但是不满足要求</span><br>    <span class="hljs-comment">//②如果第二维小于minl，那么就会出现不合法的情况</span><br>    <span class="hljs-comment">//所以minl就是答案</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">Work</span>(len);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++)<span class="hljs-comment">// 镜像</span><br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            s[i] = <span class="hljs-string">&#x27;)&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[i] = <span class="hljs-string">&#x27;(&#x27;</span>;<br><br>    <span class="hljs-built_in">reverse</span>(s + <span class="hljs-number">1</span>, s + len + <span class="hljs-number">1</span>);<span class="hljs-comment">//翻转</span><br><br>    ans = <span class="hljs-number">1LL</span> * ans * <span class="hljs-built_in">Work</span>(len) % mod;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：方法二的未简化版，dp第一维表示的是当前括号（包括左括号和右括号）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Work</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, cntr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++)&#123;<span class="hljs-comment">//这里范围变成原括号序列所有位置</span><br>        add[i] = add[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) cnt ++;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt --;<br>            cntr ++;<br>            <span class="hljs-keyword">if</span>(cnt &lt; <span class="hljs-number">0</span>) add[i] ++, cnt ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> minl = add[len];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i ++) f[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++)<span class="hljs-comment">//从左到右枚举所有括号</span><br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-comment">//右括号状态计算</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = add[i]; j &lt;= cntr; j ++) f[i][j] = (f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>]) % mod;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//左括号状态不变</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= cntr; j ++) f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br><br>    <span class="hljs-keyword">return</span> f[len][minl];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 774(Div.2) Problem C(树形背包)</title>
    <link href="/2022/03/09/cf774div2p4/"/>
    <url>/2022/03/09/cf774div2p4/</url>
    
    <content type="html"><![CDATA[<h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a><a href="https://codeforces.com/contest/1646/problem/D">原题链接</a></h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; h[N];<span class="hljs-comment">//tree</span><br><span class="hljs-type">int</span> n, ans[N];<br><span class="hljs-type">bool</span> v[N];<span class="hljs-comment">//visited</span><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dp[N][<span class="hljs-number">2</span>];<span class="hljs-comment">// &#123;max num of good vertices, min sum of weights of good vertices&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a.first == b.first) <span class="hljs-keyword">return</span> a.second &lt; b.second;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>h[u].<span class="hljs-built_in">push_back</span>(v), h[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>a.first += b.first;<br>a.second += b.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>v[i] = <span class="hljs-literal">true</span>;<br>dp[i][<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, dp[i][<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>, h[i].<span class="hljs-built_in">size</span>()&#125;;<br><span class="hljs-comment">//不好的那权值就是1，好的边上都是不好的（1），所以权值就是邻点个数*1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s : h[i])<br><span class="hljs-keyword">if</span>(!v[s])&#123;<br><span class="hljs-built_in">dfs</span>(s);<br><span class="hljs-built_in">add</span>(dp[i][<span class="hljs-number">1</span>], dp[s][<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(dp[s][<span class="hljs-number">0</span>], dp[s][<span class="hljs-number">1</span>])) <span class="hljs-built_in">add</span>(dp[i][<span class="hljs-number">0</span>], dp[s][<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(dp[i][<span class="hljs-number">0</span>], dp[s][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getAns</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">bool</span> g)</span> <span class="hljs-comment">//从上到下dp</span></span><br><span class="hljs-function"></span>&#123;<br>v[i] = <span class="hljs-literal">true</span>;<br>ans[i] = g ? h[i].<span class="hljs-built_in">size</span>() : <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s : h[i])<br><span class="hljs-keyword">if</span>(!v[s])&#123;<br><span class="hljs-keyword">if</span>(g == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(dp[s][<span class="hljs-number">0</span>], dp[s][<span class="hljs-number">1</span>])) <span class="hljs-built_in">getAns</span>(s, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">getAns</span>(s, <span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">getAns</span>(s, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//special</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;2 2\n1 1\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> v);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])) <span class="hljs-built_in">getAns</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), cout &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">getAns</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), cout &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>].first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>].second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1TL4y1u7P7?p=4">Bilibili</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOJ没有上司的舞会2（树形背包）</title>
    <link href="/2022/03/08/DOJ%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A2/"/>
    <url>/2022/03/08/DOJ%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A2/</url>
    
    <content type="html"><![CDATA[<p><a href="http://oj.daimayuan.top/course/5/problem/219">原题链接</a></p><h1 id="没有上司的舞会2"><a href="#没有上司的舞会2" class="headerlink" title="没有上司的舞会2"></a>没有上司的舞会2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一家公司里有 $n$ 个员工，除了公司 CEO 外，每个人都有一个直接上司。今天公司要办一个舞会，为了大家玩得尽兴，如果某个员工的直接上司来了，他&#x2F;她就不想来了。第 $i$ 个员工来参加舞会会为大家带来 $a_i$ 点快乐值。由于场地有大小限制，场地最多只能容纳 $m$ 个人。请求出快乐值最大是多少。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行2个整数$n,m$。</p><p>接下来一行，$n-1$个整数$f_2,f_3…f_n$，$f_i(2\le i\le n)$表示第$i$个员工的上司。其中$1$号点为CEO，没有上司。</p><p>接下来一行，$n$个整数$a_1,a_2…a_n$表示每个员工的快乐值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示答案。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">16<br></code></pre></td></tr></table></figure><h2 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h2><p>对于所有数据，保证$2\le n \le 500, 0 \le m \le n,1 \le a_i \le 100000$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">505</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; h[N];<br><span class="hljs-type">int</span> f[N][N][<span class="hljs-number">2</span>], w[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//把结点i看成一个容量为m的背包</span><br><span class="hljs-comment">//每一个直接子树都看成一种物品（每种物品最多取m个）</span><br><span class="hljs-comment">//遍历每一个直接子树</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s : h[i])<br>&#123;<br><span class="hljs-built_in">dfs</span>(s);<br><span class="hljs-comment">//先递归处理子树</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j --)<br>&#123;<br><span class="hljs-comment">//在s和s之前最多取了j个物品（占用了j容量）</span><br><span class="hljs-comment">//为了保证一次循环中，s不会被取多次（即不会更新之后又用它更新其他的情况）</span><br><span class="hljs-comment">//所以j从大到小遍历，因为下面状态更新的时候只会调用比j小的状态</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= j; k ++)<br>&#123;<br><span class="hljs-comment">//枚举取0~j个s物品的情况，0表示i不取，1表示i取</span><br>f[i][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">0</span>], f[i][j - k][<span class="hljs-number">0</span>] + <span class="hljs-built_in">max</span>(f[s][k][<span class="hljs-number">1</span>], f[s][k][<span class="hljs-number">0</span>]));<br><span class="hljs-comment">//f[i][j - k][0]表示上一个状态下，最多取j-k个物品的最大价值，这样就可以再取k个s物品</span><br><span class="hljs-comment">//因为i没取，所以可以从直接孩子取或不取里面取最大的</span><br>f[i][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">1</span>], f[i][j - k][<span class="hljs-number">1</span>] + f[s][k][<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//因为i也取，所以只能从f[s][k][0]转移</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//但是实际上，我们得到的f[i][j][1]是以i为背包，最多取j个物品的最大价值，里面并不包含i物品本身</span><br><span class="hljs-comment">//所以我们需要再把i物品加进去，因此在最多取j-1个物品的最大价值里面加上i物品的价值即可</span><br><span class="hljs-comment">//这样我们的f[i][j][1]就表示以i为背包，最多取j个物品，里面且包含i物品本身的最大价值</span><br><span class="hljs-comment">//同样为了重复计算，我们要从大到小遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j; j --)<br>f[i][j][<span class="hljs-number">1</span>] = f[i][j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + w[i];<br><br><span class="hljs-comment">// f[i][0][1] = 0; //默认是0，所以无所谓</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br><br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)&#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    h[x].<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br>cout &lt;&lt; <span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][m][<span class="hljs-number">1</span>], f[<span class="hljs-number">1</span>][m][<span class="hljs-number">0</span>]) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 775(Div.2) Problem C Weird Sum(匿名函数的使用)</title>
    <link href="/2022/03/07/cf775div2p3/"/>
    <url>/2022/03/07/cf775div2p3/</url>
    
    <content type="html"><![CDATA[<h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a><a href="https://codeforces.com/contest/1649/problem/C">原题链接</a></h2><h2 id="C-Lambda函数（匿名函数）的使用方法"><a href="#C-Lambda函数（匿名函数）的使用方法" class="headerlink" title="C++ Lambda函数（匿名函数）的使用方法"></a>C++ Lambda函数（匿名函数）的使用方法</h2><p>​    首先了解一下 C++ 匿名函数的基本使用方法</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//[捕获列表](参数列表)-&gt;返回类型&#123;函数体&#125;</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p>​    <code>[]</code>：空捕获列表，Lambda不能使用所在函数中的变量。</p><p>​    <code>[&amp;]</code>：隐式捕获列表，Lambda体内使用的局部变量都按引用方式传递。</p><p>​    <code>[=]</code>：隐式捕获列表，Lambda体内使用的局部变量都按值传递。</p><h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>​    可以不填，默认为return语句返回值的返回类型。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="$sort$排序"></a>$sort$排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> cmp = [&amp;](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p2)&#123;<br><span class="hljs-keyword">return</span> p1.second &lt; p2.second;<br>&#125;;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b)&#123;<br><span class="hljs-keyword">return</span> a.second &lt; b.second;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在-main-函数里写递归调用"><a href="#在-main-函数里写递归调用" class="headerlink" title="在$main$函数里写递归调用"></a>在$main$函数里写递归调用</h4><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//在匿名函数中第一个参数是自身，且在内部都使用那个名字</span><br>        <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;self, TreeNode *root)-&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">self</span>(self, root-&gt;left), <span class="hljs-built_in">self</span>(self, root-&gt;right)) + <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(dfs, root);<span class="hljs-comment">//别忘了参数要有自身</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxsum = <span class="hljs-number">-2e9</span>;<br>        <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;self, TreeNode* root) -&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">self</span>(self, root-&gt;left), <span class="hljs-number">0</span>), r = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">self</span>(self, root-&gt;right), <span class="hljs-number">0</span>);<br>            maxsum = <span class="hljs-built_in">max</span>(maxsum, root-&gt;val + l + r);<br>            <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(l, r);<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(dfs, root);<br>        <span class="hljs-keyword">return</span> maxsum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>$function$类调用$lambda$函数</p><p><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countMaxOrSubsets</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> cur)&#123;<br>            <span class="hljs-keyword">if</span>(idx == n)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(cur &gt; mx) mx = cur, ans = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == mx) ans ++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(idx + <span class="hljs-number">1</span>, cur | a[idx]);<br>            <span class="hljs-built_in">dfs</span>(idx + <span class="hljs-number">1</span>, cur);<br>        &#125;;<br><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="本题题意"><a href="#本题题意" class="headerlink" title="本题题意"></a>本题题意</h2><p>​    给一个$n*m$的表格，每个单元格里面有一个数字，代表一种颜色，求所有两两相同颜色的单元格的<a href="https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092">曼哈顿距离</a>之和。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    1.用$map&lt;int, pair&lt;int,int&gt;&gt;$记录所有颜色所在的单元格。</p><p>​    2.对某一种颜色，我们将其横坐标排序，遍历每一个横坐标，假设当前位置为$i$，我们记录前面所有的横坐标总个数$cnt$以及所有横坐标之和$sum$，不难证明，当前横坐标和前面所有横坐标的距离之和为$cnt * i - sum$，因此，我们可以得到当前颜色的所有横坐标两两组合的距离之和，并且由于我们是从小到大枚举，所以得到的答案就是两两横坐标距离差的绝对值之和，即曼哈顿距离的要求。</p><p>​    3.同样的，我们对纵坐标进行操作，最后两者相加即是答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>map&lt;<span class="hljs-type">int</span>, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; mp;<br><br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>mp[x].<span class="hljs-built_in">push_back</span>(&#123;i, j&#125;);<br>&#125;<br><br><span class="hljs-comment">// auto cmp = [&amp;](pair&lt;int, int&gt; p1, pair&lt;int, int&gt; p2)&#123;</span><br><span class="hljs-comment">// return p1.second &lt; p2.second;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-keyword">auto</span> sol = [&amp;](vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; v)&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;[i, j] : v)<br>&#123;<br>res += i * cnt - sum;<br>sum += i;<br>cnt ++;<br>&#125;<br>cnt = sum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// sort(v.begin(), v.end(), cmp);</span><br><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b)&#123;<br><span class="hljs-keyword">return</span> a.second &lt; b.second;<br>&#125;);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;[j, i] : v)<br>&#123;<br>res += i * cnt - sum;<br>sum += i;<br>cnt ++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;[c, v] : mp)<br>ans += <span class="hljs-built_in">sol</span>(v);<br><br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOJ Daily Div2 107 饿饿 饭饭（二分/模拟）</title>
    <link href="/2022/03/04/DOJ-Daily-Div2-107-%E9%A5%BF%E9%A5%BF-%E9%A5%AD%E9%A5%AD/"/>
    <url>/2022/03/04/DOJ-Daily-Div2-107-%E9%A5%BF%E9%A5%BF-%E9%A5%AD%E9%A5%AD/</url>
    
    <content type="html"><![CDATA[<p><a href="http://oj.daimayuan.top/course/11/problem/463">原题链接</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>食堂排队，队伍里第$i$个人想吃$a_i$碗，但是每次只能打一碗饭，打完就去后面继续排。食堂一共就一个窗口，请问发出去$k$碗饭之后，队伍是什么样子的。如果还有人，按当前队伍输出每个人的编号；如果k碗饭没发完就没人了，输出”-1”。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行给出两个整数$n,k$。</p><p>第二行给出$n$个整数$a_1,a_2…a_n$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果食堂阿姨打饭数少于k，请输出”-1”。</p><p>否则按照队伍顺序输出每一个同学的编号。</p><h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><h4 id="样例输入3"><a href="#样例输入3" class="headerlink" title="样例输入3"></a>样例输入3</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出3"><a href="#样例输出3" class="headerlink" title="样例输出3"></a>样例输出3</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>第一步，每次找到队伍中吃最少的那个，让所有人都吃那么多，然后那个人就吃饱溜了。直到剩下的饭不够这么干。第二部，剩下的饭再试着每个人都发一碗，看看能发几次。第三步，剩下的饭不够每个人都发一碗的，这个时候才会有人打了饭排到后面去，我们枚举每个剩下的人，如果他打了饭排到后面去了，就push到一个数组，剩下的push到另一个数组，最后分别输出即可。</p><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>思路1是一步一步找到最后其中第三步的情况的，我们也可以二分以下我们一共发了多少轮饭（一轮表示每个人都发一碗），最后处理方式同上。</p><h4 id="代码（模拟）"><a href="#代码（模拟）" class="headerlink" title="代码（模拟）"></a>代码（模拟）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, k, a[<span class="hljs-number">100010</span>], b[<span class="hljs-number">100010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i], b[i] = a[i];<br><span class="hljs-built_in">sort</span>(a, a + n);<br><span class="hljs-comment">//排个序，每次找吃的最少的把他干了</span><br><span class="hljs-comment">//怎么干，他吃多少碗，那所有人都吃多少碗</span><br><span class="hljs-comment">//那么所有人的相对顺序是不变的</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>, left = n;<br><span class="hljs-comment">//cnt记录还在排队的人都吃了多少碗，left记录还剩下多少人排队</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br><span class="hljs-comment">//一次干走一个人，他吃多少碗那大家都吃多少碗</span><br><span class="hljs-keyword">if</span>(k &lt; (a[i] - cnt) * left) <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//如果每个人都吃(a[i]-cnt)个的话，剩下的k碗不够吃了，那剩下的人就都不会被干走</span><br><span class="hljs-keyword">else</span><br>&#123;<br>k -= (a[i] - cnt) * left;<br><span class="hljs-comment">//否则每个人都吃a[i]-cnt碗，为什么不是a[i]因为i号人他之前吃了cnt碗了，再吃a[i]-cnt碗就饱了</span><br>cnt += (a[i] - cnt);<br><span class="hljs-comment">//记录一下剩下的人已经吃了多少碗</span><br>left --;<br><span class="hljs-comment">//赶走吃饱的人</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!left &amp;&amp; k) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<span class="hljs-comment">//如果没有人，并且还有饭</span><br><span class="hljs-keyword">else</span><br>&#123;<br>cnt += k / left;<br><span class="hljs-comment">//剩下的饭先平分给剩下的人，这时的排队相对顺序和开始时候是一样的</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> h = k % left;<br><span class="hljs-comment">//这个h就是平分给剩下的人之后剩下来的饭，但是它不够每个人吃一碗</span><br><span class="hljs-comment">//那么我们就给排在前面还能吃的人再吃一碗</span><br>vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans1, ans2;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br><span class="hljs-keyword">if</span>(b[i] &gt; cnt)<span class="hljs-comment">//如果他现在还在队伍里</span><br>&#123;<br><span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//如果生下来的饭没发完</span><br>&#123;<br><span class="hljs-keyword">if</span>(b[i] &gt; cnt + <span class="hljs-number">1</span>) ans1.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>)；<br><span class="hljs-comment">//如果i还在队伍里，并且吃了一碗之后还没吃饱，那他就排到队伍后面</span><br>h --;<span class="hljs-comment">//发完一碗</span><br>&#125;<br><span class="hljs-keyword">else</span> ans2.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//剩下的饭都发完了(h=0),那下面留下的人就都在队头</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : ans2) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//输出队头</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : ans1) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//输出队尾</span><br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P2602 数字计数(数位dp)</title>
    <link href="/2022/03/01/Luogu-P2602-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/"/>
    <url>/2022/03/01/Luogu-P2602-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="P2602-ZJOI2010-数字计数"><a href="#P2602-ZJOI2010-数字计数" class="headerlink" title="P2602 [ZJOI2010]数字计数"></a>P2602 [ZJOI2010]数字计数</h1><p>原题链接 <a href="https://www.luogu.com.cn/problem/P2602">洛谷</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个正整数 $a$和 $b$，求在 $[a,b]$中的所有整数中，每个数码(digit)各出现了多少次。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>仅包含一行两个整数  $a$和 $b$，含义如上所述。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>包含一行十个整数，分别表示$0$~$9$ 在$[a,b]$中出现了多少次。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p>输出 #1</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="说明-x2F-提示"><a href="#说明-x2F-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p><strong>数据规模与约定</strong></p><ul><li>对于30%的数据，保证 $a\le b \le 10^6$；</li><li>对于100%的数据，保证  $1\le a\le b \le 10^{12}$。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由暴力打表&#x2F;数学推导</p><p>有公式  $$f[i]&#x3D;10*f[i-1]+10^{i-1}$$ </p><p>即 $$f[i]&#x3D;i*10^{i-1}$$</p><p>表示所有$i$位数里0~9每一个数的个数（包含前导0，如001,002,003都是三位数，且01,001,0001看作不同的数)</p><p>考虑$i$位数，和$i-1$位数之间的关系：如 $abcd$ 拆成$0bcd, 1bcd, 2bcd….abcd$，从而进行计算</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N], num[N], cnt[N], ten[N], ans[N];<br><span class="hljs-comment">//f[i]: 0 ~ 10^i-1 中每个数出现了几次(包含前导0)</span><br><span class="hljs-comment">//num:记录每一位数是多少    cnt:0~9每一个数出现过多少次     ten:记录10的i次方的值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">bool</span> plus)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> cnt);<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<span class="hljs-comment">//这个数的长度or位数</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> m = n;<br>    <span class="hljs-keyword">while</span>(n) num[++ len] = n % <span class="hljs-number">10</span>, n /= <span class="hljs-number">10</span>;<span class="hljs-comment">// num[i]表示第i位数</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len; i &gt;= <span class="hljs-number">1</span>; i --)<span class="hljs-comment">//从最高位开始，枚举数的长度（位数）</span><br>    &#123;<br>        <span class="hljs-comment">//数字x的出现次数分为两部分（第i位x的个数，小于i位x的个数）</span><br>        <span class="hljs-comment">//所有不在i位上的x</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j ++)<br>            cnt[j] += num[i] * f[i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//所有第i位上的x</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num[i]; j ++)<br>            cnt[j] += ten[i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//特殊的，对于x=nums[i]，我们后面选择的总数就不是10的i-1次方了，而是n % (10^i) + 1</span><br>        cnt[num[i]] += m % ten[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//去掉前导0</span><br>        cnt[<span class="hljs-number">0</span>] -= ten[i - <span class="hljs-number">1</span>]; <br>        <span class="hljs-comment">//0有1种, 00,01,02...09有10^1种, 000,001,002...099有10^2种</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(plus) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i ++) ans[i] += cnt[i];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i ++) ans[i] -= cnt[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);<br>    ten[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">15</span>; i ++)<br>        ten[i] = <span class="hljs-number">10</span> * ten[i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">15</span>; i ++)<br>        f[i] = <span class="hljs-number">10</span> * f[i - <span class="hljs-number">1</span>] + ten[i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-built_in">sol</span>(a - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">sol</span>(b, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, ans[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 765(Div.2) Problem C(两种DP方式)</title>
    <link href="/2022/03/01/cf765div2p3/"/>
    <url>/2022/03/01/cf765div2p3/</url>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-765-Div-2-Problem-C"><a href="#Codeforces-Round-765-Div-2-Problem-C" class="headerlink" title="Codeforces Round #765 (Div. 2) Problem C"></a>Codeforces Round #765 (Div. 2) Problem C</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/contest/1625/problem/C">Codeforces</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>​        两地间距$l$千米，路上有$n$个路牌，第$i$个路牌的数字$a_i$表示必须以$a_i$分钟每千米的速度走到下一个路牌，$d[i]$表示到起点的距离。问拆掉$k$个路牌(第一个不能拆)，最短需要多少分钟就能到哪目的地。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>​        拿掉一个路牌之后会影响到到达后面一个路牌的时间，并且数据范围比较小，考虑$dp$。</p><p>​        $f[i][j]$表示到第$i$个路牌,已经去掉了$j$个路牌,并且第$i$个路牌不去掉的最短时间。$f[i][j]$可以由$i$前面的某个路牌$f[p][old_j]$直接到达，此时第$p+1$到$i-1$个路牌都被拆掉，$p$到$i$所需要的时间是$f[p][old_j]+(d[i]-d[p])*a[p]$，枚举每一个可能情况取$min$即可。</p><p>​        <strong>注意我们的$i$的范围是$0$到$n$，题目中只给了$0$到$n-1$一共$n$个路牌。为了方便我们在最后再加一个路牌。</strong></p><p>​        最后的$f[n][j]$表示走到第$n$个路牌，第$n$个路牌不拆，且前面一共拆了$j$个路牌，需要的最短时间。因为我们自己放置的路牌本就不存在，所以不能拆掉，正好就是我们要求的答案。而我们目前不知道拆掉几个的时候时间最短，所以对$f[n][0]$到$f[n][k]$取最小值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">505</span>;<br><span class="hljs-type">int</span> f[N][N], a[N], d[N];<br><span class="hljs-comment">//f[i][j] 到第i个路标,已经去掉了j个路标,并且第i个路标不去掉的最短时间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, l, k;<br>cin &gt;&gt; n &gt;&gt; l &gt;&gt; k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; d[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<br><br>d[n] = l, a[n] = <span class="hljs-number">0</span>;<span class="hljs-comment">//终点加一个路标方便算</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j ++)<br>f[i][j] = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    初始化初始状态，方便下面取min不会出错</span><br><span class="hljs-comment">    当然，也可以在下面递归的过程中初始化f[i][j]</span><br><span class="hljs-comment">    */</span><br><br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<span class="hljs-comment">//第i个路标(从起点后面的那个路标开始算)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; j ++)&#123;<span class="hljs-comment">//前面去掉了j个路标</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            f[i][j] = f[i - 1][j] + (d[i] - d[i - 1]) * a[i - 1];</span><br><span class="hljs-comment">            上面不初始化为无限大就加一句这个，下面也可以变成 p &lt; i - 1</span><br><span class="hljs-comment">            */</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; i; p ++)&#123;<span class="hljs-comment">//i前面第一个没有去掉的路标p</span><br><span class="hljs-type">int</span> old_j = j - (i - p - <span class="hljs-number">1</span>);<span class="hljs-comment">//p前面去掉的路标数(p+1 ~ i-1的路标全部去掉了)</span><br><span class="hljs-keyword">if</span>(old_j &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//如果p前面可以去掉old_j个路标</span><br>f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[p][old_j] + (d[i] - d[p]) * a[p]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i ++) ans = <span class="hljs-built_in">min</span>(ans, f[n][i]);<br><br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>上面的$dp$函数$f[i][j]$的第二维$j$表示前面拆掉了多少个路牌，那么我们也可以将其表示为选择多少个路牌。最后在选择了$n-k$到$n$个路牌里面取最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">505</span>;<br><span class="hljs-type">int</span> f[N][N], a[N], d[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, l, k;<br>cin &gt;&gt; n &gt;&gt; l &gt;&gt; k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; d[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<br><br>d[n] = l, a[n] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j ++)<br>f[i][j] = <span class="hljs-number">1e9</span>;<br><br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<span class="hljs-comment">//到达原第i个路标的位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++)<span class="hljs-comment">//一共选择了j个路标(包括i)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; i; p ++)<span class="hljs-comment">//枚举i是从哪个路标过来的</span><br>f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[p][j - <span class="hljs-number">1</span>] + (d[i] - d[p]) * a[p]);<br><br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - k; i &lt;= n; i ++) ans = <span class="hljs-built_in">min</span>(ans, f[n][i]);<br><br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>solves</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hexo+Nginx+Git在云服务器上搭建个人网站</title>
    <link href="/2022/02/28/newHexoBlog/"/>
    <url>/2022/02/28/newHexoBlog/</url>
    
    <content type="html"><![CDATA[<p>​        </p><h1 id="基于Hexo-Nginx-Git在云服务器上搭建个人网站"><a href="#基于Hexo-Nginx-Git在云服务器上搭建个人网站" class="headerlink" title="基于Hexo+Nginx+Git在云服务器上搭建个人网站"></a>基于Hexo+Nginx+Git在云服务器上搭建个人网站</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本地环境：Windows11专业版 21H2    </p><p>云服务器：腾讯云 轻量应用服务器 Ubuntu Server 20.04 LTS 64bit</p><h2 id="本地端"><a href="#本地端" class="headerlink" title="本地端"></a>本地端</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>  <a href="https://git-scm.com/">Git</a> <a href="https://www.runoob.com/git/git-tutorial.html">Git 教程</a></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p> <a href="https://nodejs.org/en/">Node.js</a></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>打开 Git Bash，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br>hexo version<br></code></pre></td></tr></table></figure><img src="/2022/02/28/newHexoBlog/hexover.png" alt style="zoom:67%;"><p>显示出版本号则成功。</p><p>自定义博客文件夹名，默认生成在C盘用户文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br></code></pre></td></tr></table></figure><p><strong>小技巧：在myblog文件夹上右键点击“Git Bash Here” 即可快速打开bash到这个文件夹内。</strong></p><p>测试Hexo是否能生成网页：</p><p>输入<code>hexo generate</code>  或者 <code>hexo g</code> ：生成静态文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><p>输入 <code>hexo server - port xxxx</code> 或者 <code>hexo s -p xxxx</code> 在指定端口启动本地服务器(默认在4000端口)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server - port xxxx<br></code></pre></td></tr></table></figure><img src="/2022/02/28/newHexoBlog/hexospo.png"><p>在本地访问<code>localhost:xxxx</code>或者在上面指令后加 <code>-o</code> 即可打开Hexo博客主页。</p><p>默认是landscape主题，图中是NexT主题。</p><img src="/2022/02/28/newHexoBlog/localhost4000.png" alt style="zoom: 33%;"><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>通过服务器官方网页登陆或者SSH登录服务器终端（PuTTY&#x2F;XShell）。</p><h3 id="安装Git和Nginx"><a href="#安装Git和Nginx" class="headerlink" title="安装Git和Nginx"></a>安装Git和Nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get install git nginx -y<br></code></pre></td></tr></table></figure><h3 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h3><p>建立文件路径并修改权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /var/repo/<br><span class="hljs-built_in">chown</span> -R <span class="hljs-variable">$USER</span>:<span class="hljs-variable">$USER</span> /var/repo/<br><span class="hljs-built_in">chmod</span> -R 755 /var/repo/<br></code></pre></td></tr></table></figure><p>创建远程Git仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/repo<br>git init --bare myblog.git<br></code></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>创建目录并修改目录所有权和权限，用于存放静态网页文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /var/www/hexo<br><span class="hljs-built_in">chown</span> -R <span class="hljs-variable">$USER</span>:<span class="hljs-variable">$USER</span> /var/www/hexo<br><span class="hljs-built_in">chmod</span> -R 755 /var/www/hexo<br></code></pre></td></tr></table></figure><p>修改Nginx的配置文件，把网页根目录指向刚刚创建的文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/nginx/sites-available/default<br></code></pre></td></tr></table></figure><img src="/2022/02/28/newHexoBlog/nginxroot.png" alt style="zoom: 67%;"><p>重启Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service nginx restart<br></code></pre></td></tr></table></figure><p>此时浏览器输入自己的公网ip就可以访问到Nginx的空页（403 Forbidden）。</p><img src="/2022/02/28/newHexoBlog/403 forbidden.png" alt style="zoom: 50%;"><h3 id="配置Git-hooks文件"><a href="#配置Git-hooks文件" class="headerlink" title="配置Git hooks文件"></a>配置Git hooks文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /var/repo/myblog.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>打开文件，输入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>git --work-tree=/var/www/hexo --git-dir=/var/repo/myblog.git checkout -f<br></code></pre></td></tr></table></figure><p>保存后修改权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /var/repo/myblog.git/hooks/post-receive<br></code></pre></td></tr></table></figure><h3 id="部署本地Hexo"><a href="#部署本地Hexo" class="headerlink" title="部署本地Hexo"></a>部署本地Hexo</h3><p>回到本地hexo文件夹，Git Bash输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> root@&#123;云服务器IP&#125;:/var/repo/myblog.git<br></code></pre></td></tr></table></figure><p>然后修改文件夹中的配置文件 “_config.yml”：</p><p>找到”url：” 将后面的网址改为服务器网址。</p><img src="/2022/02/28/newHexoBlog/url.png" alt style="zoom: 67%;"><p>找到”deploy”，改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br> <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;git&#x27;</span><br> repo:   &#123;服务器用户名&#125;@&#123;服务IP&#125;:/var/repo/myblog.git：<br></code></pre></td></tr></table></figure><img src="/2022/02/28/newHexoBlog/deploy.png" alt style="zoom: 67%;"><p>保存后，在Bash输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g -d<br></code></pre></td></tr></table></figure><img src="/2022/02/28/newHexoBlog/pswd.png" alt style="zoom: 67%;"><p>输入服务器的密码，完成部署。</p><p>当然，我们也可以不用输入密码就可以连接服务器</p><h3 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;your username&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your email&quot;</span><br><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your email&quot;</span><br></code></pre></td></tr></table></figure><p>输入后会有三次询问，不管直接回车即可。</p><p>之后在C盘用户文件夹里就会出现.ssh文件夹，里面的id_rsa.pub就是密钥。</p><h3 id="建立SSH信任关系"><a href="#建立SSH信任关系" class="headerlink" title="建立SSH信任关系"></a>建立SSH信任关系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-copy-id -i ~/.ssh/id_rsa.pub &#123;服务器用户名&#125;@&#123;服务器ip&#125;<br>ssh -T &#123;服务器用户名&#125;@&#123;服务器ip&#125;<br></code></pre></td></tr></table></figure><img src="/2022/02/28/newHexoBlog/ssh.png" alt style="zoom: 67%;"><img src="/2022/02/28/newHexoBlog/sshlogout.png" alt style="zoom: 67%;"><p>如果不需要密码就可以直接登录，说明配置成功。</p><img src="/2022/02/28/newHexoBlog/final.png"><p>至此，就可以使用你的服务器ip或者域名进入博客啦。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>经过一天的折腾，终于在服务器上成功部署了Hexo博客。曾经遇到过部署之后样式全部丢失的情况，在网上找了许多方法都不能解决。网上大部分教程都是将Hexo部署在Github或者Gitee上面，而部署在服务器上的教程并不多，所以写这一篇记录一下第一次搭建Hexo的过程。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在文章中插入图片：除了修改hexo配置文件和插件文件之外，md的插入图片代码也要写成类似<code>&lt;img src=&quot;newHexoBlog\final.png&quot;/&gt;</code>的形式，前面没有<code>&quot;\&quot;</code>。写成<code>![]()</code>在我的环境下是显示不出来的，原因可能与这个有关：<a href="https://www.jianshu.com/p/75a8b0d9b969">HEXO博客文章图片展示问题</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>​    <a href="https://blog.0xfaner.top/posts/hexo-config-guide/">Hexo 博客配置指南</a></p><p>​    <a href="https://blog.csdn.net/weixin_43340015/article/details/120831536">阿里云服务器+Hexo+Nginx搭建个人博客网站</a></p><p>​    <a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片（详细版）</a> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统C复习</title>
    <link href="/2022/02/28/SignalAndSystem/"/>
    <url>/2022/02/28/SignalAndSystem/</url>
    
    <content type="html"><![CDATA[<h1 id="信号与系统C复习-2021-12-23"><a href="#信号与系统C复习-2021-12-23" class="headerlink" title="信号与系统C复习 2021.12.23"></a>信号与系统C复习 2021.12.23</h1><h2 id="第1章-信号与系统的基本概念"><a href="#第1章-信号与系统的基本概念" class="headerlink" title="第1章 信号与系统的基本概念"></a>第1章 信号与系统的基本概念</h2><h3 id="1-1-信号的描述和分类"><a href="#1-1-信号的描述和分类" class="headerlink" title="1.1 信号的描述和分类"></a>1.1 信号的描述和分类</h3><h4 id="1-1-1-信号的特性"><a href="#1-1-1-信号的特性" class="headerlink" title="1.1.1 信号的特性"></a>1.1.1 信号的特性</h4><p>​    时域特性和频率特性。</p><p>​    (1) 时域：幅度随时间变化（表示为时间t的函数）。</p><p>​    (2) 频率：各正弦谐波分量的振幅和初相随时间变化（分解为许多不同频率的正弦分量）。</p><h4 id="1-1-2-信号的分类"><a href="#1-1-2-信号的分类" class="headerlink" title="1.1.2 信号的分类"></a>1.1.2 信号的分类</h4><p>​    确定和随机信号、连续时间$f(t)$ 和 离散时间$f(t_k)$，$f(kT)$，$f(k)$信号、<strong>周期和非周期信号。</strong></p><h4 id="1-1-3-信号周期性的判断"><a href="#1-1-3-信号周期性的判断" class="headerlink" title="1.1.3 信号周期性的判断"></a>1.1.3 信号周期性的判断</h4><p><strong>(1)</strong> <strong>连续信号：$T_1,T_2$存在最小公倍数，即$T_1&#x2F;T_2&#x3D;n_1&#x2F;n_2$为有理数，周期$T&#x3D;n_1T_1&#x3D;n_2T_2$，$n_1$和$n_2$为整数。</strong></p><p>​    $f_T(t) &#x3D; f_T(t + T) (-\infty &lt; t &lt; \infty)$</p><p>​    <strong>周期 $T&#x3D;2\pi&#x2F;\omega_0$</strong></p><p>​    <strong>角频率 $\omega_0 &#x3D; 2\pi &#x2F; T (rad &#x2F; s)$</strong></p><p><strong>(2)</strong> <strong>离散信号：正弦序列 $x(k) &#x3D; Asin(\Omega_0k + \varphi)$，当$\Omega_0 &#x2F; 2\pi &#x3D; m &#x2F; N$是有理数时，为周期序列，周期为N，是无理数时，为非周期序列。</strong></p><p>​    $f_N(k)&#x3D;f_N(k+N)(-\infty&lt;k&lt;\infty,k和N取整数)$</p><p>​    周期$N$</p><p>​    数字角频率$\Omega_0&#x3D;\omega_0T_s(rad)$</p><h4 id="考点"><a href="#考点" class="headerlink" title="考点"></a><u><em><strong>考点</strong></em></u></h4><p><em><strong>想要判断是周期 &#x2F; 非周期信号，连续就用 $T_1&#x2F;T_2&#x3D;n_1&#x2F;n_2$是有理数结合 $T&#x3D;2\pi&#x2F;\omega_0$，离散就用 $\Omega_0 &#x2F; 2\pi &#x3D; m &#x2F; N$是有理数。</strong></em></p><h3 id="1-2-系统的描述和分类"><a href="#1-2-系统的描述和分类" class="headerlink" title="1.2 系统的描述和分类"></a>1.2 系统的描述和分类</h3><h4 id="1-2-1-系统的分类"><a href="#1-2-1-系统的分类" class="headerlink" title="1.2.1 系统的分类"></a>1.2.1 系统的分类</h4><p>​    连续和离散时间系统、线性和非线性系统、时变和时不变系统。</p><h4 id="1-2-2-连续时间和离散时间系统"><a href="#1-2-2-连续时间和离散时间系统" class="headerlink" title="1.2.2 连续时间和离散时间系统"></a>1.2.2 连续时间和离散时间系统</h4><p>​    输入和输出都是连续（离散）时间信号的系统。</p><h4 id="1-2-3-线性系统和非线性系统"><a href="#1-2-3-线性系统和非线性系统" class="headerlink" title="1.2.3 线性系统和非线性系统"></a>1.2.3 <strong>线性系统</strong>和非线性系统</h4><h5 id="1-线性特性"><a href="#1-线性特性" class="headerlink" title="(1) 线性特性"></a>(1) 线性特性</h5><p>​        齐次性：若$x(t)\rightarrow y(t)$，则$kx(t)\rightarrow ky(t)$</p><p>​        叠加性：若$x_1(t)\rightarrow y_1(t)$，$x_2(t)\rightarrow y_2(t)$，则$x_1(t) + x_2(t)\rightarrow y_1(t)+y_2(t)$ </p><p>​        <strong>线性系统：</strong>若$x_1(t)\rightarrow y_1(t)$，$x_2(t)\rightarrow y_2(t)$，则$k_1x_1(t) + k_2x_2(t)\rightarrow k_1y_1(t)+k_2y_2(t)$ </p><h4 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a><u><em>考点</em></u></h4><p><em><strong>对于不具有初始状态的系统，想要判断是线性 &#x2F; 非线性系统，只要判断是否满足上述条件。</strong></em></p><h5 id="2-具有初始状态的系统"><a href="#2-具有初始状态的系统" class="headerlink" title="(2) 具有初始状态的系统"></a>(2) 具有初始状态的系统</h5><p>​        其响应包括：</p><p>​        <strong>零状态响应</strong>$y_{zs}(t)$：初始状态为零，仅由外部激励作用引起的响应。</p><p>​        <strong>零输入响应</strong>$y_{zi}(t)$：外部激励为零，仅由初始状态作用引起的响应。</p><p>​        <strong>全响应</strong>$y(t)$：两个共同作用，称为完全响应。</p><p>​        对于<strong>具有初始状态</strong>的线性系统应具有下列特性：</p><p>​        <strong>a.分解性 ：</strong>全相应 &#x3D; 零输入响应 + 零状态响应</p><p>​        <strong>b.零输入线性：</strong>系统有多个初始状态时，零输入响应对每个初始状态呈线性。</p><p>​        <strong>c.零状态线性：</strong>系统有多个输入时，零状态响应对每个输入呈线性。</p><h4 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a><u><em>考点</em></u></h4><p><em><strong>对于具有初始状态的系统，想要判断是线性 &#x2F; 非线性系统，就要判断是否满足三个条件：</strong></em></p><p><em><strong>1.分解性。</strong></em></p><p><em><strong>2.零输入线性。</strong></em></p><p><em><strong>3.零状态线性。</strong></em></p><p><strong>例如：</strong></p><p> $y(t)&#x3D;3x(t)+2q(0)$ ：</p><p>(1)    零状态响应：$y_{zs}(t) &#x3D; 3x(t)$     零输入响应：$y_{zi}&#x3D;2q(0)$    系统具有可分解性。</p><p>(2)    假设    $x_1(t)$    单独激励的零状态响应为    $y_{1zs}&#x3D;3x_1(t)$，    $x_2(t)$    为    $y_{2zs}&#x3D;3x_2(t)$</p><p>​        则当激励为    $x_a(t)&#x3D;k_1x_1(t)+k_2x_2(t)$    </p><p>​        系统零状态响应为    $y_{azs}(t)&#x3D;3x_a(t)&#x3D;3[k_1x_1(t)+k_2x_2(t)]$</p><p>​        而    $k_1y_{1zs}(t)+k_2y_{2zs}(t)&#x3D;k_1[3x_1(t)]+k_2[3x_2(t)]&#x3D;y_{azs}(t)$</p><p>​        所以零状态响应满足线性。</p><p>(3)    假设    $y_{1zi}&#x3D;2q_1(0)$    $y_{2zi}&#x3D;2q_2(0)$    </p><p>​        则当初始状态    $q_a(0)&#x3D;k_1q_1(0)+k_2q_2(0)$</p><p>​        系统的零输入响应为    $y_{azi}(t)&#x3D;2[k_1q_1(0)+k_2q_2(0)]$</p><p>​        而    $k_1y_{1zi}(t)+k_2y_{2zi}(t)&#x3D;k_1[2q_1(0)]+k_2[q_2(0)]&#x3D;y_{azi}(t)$</p><p>​        所以零输入响应满足线性。</p><p>所以，该系统同时满足线性系统的三个条件，所以是线性系统。</p><p>​        </p><h4 id="1-2-4-时不变系统和时变系统"><a href="#1-2-4-时不变系统和时变系统" class="headerlink" title="1.2.4 时不变系统和时变系统"></a>1.2.4 时不变系统和时变系统</h4><p>​    时不变系统：系统的<strong>零状态响应</strong>的特性不随时间的变化而改变。即</p><p>若    $x(t)\rightarrow y(t)$    则    $x(t-t_d)\rightarrow y(t-t_d)$</p><h4 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a><u><em>考点</em></u></h4><p><em><strong>想要判断系统是时变 &#x2F; 时不变系统，只要判断是否满足上述条件</strong></em>。</p><p><strong>例如：</strong></p><p>$y(t)&#x3D;sin[x(t)]$ ：</p><p>$x_1(t)\rightarrow y_1(t) &#x3D; sin[x_1(t)]$</p><p>若    $x_1(t)&#x3D;x(t-t_d)\rightarrow y_1(t)&#x3D;sin[x_1(t)]&#x3D;sin[x(t-t_d)]$</p><p>而    $y(t-t_d) &#x3D; sin[x(t - t_d)]&#x3D;y_1(t)$</p><p>所以该系统为时不变系统。</p><h4 id="1-2-5-因果系统和非因果系统"><a href="#1-2-5-因果系统和非因果系统" class="headerlink" title="1.2.5 因果系统和非因果系统"></a>1.2.5 因果系统和非因果系统</h4><p>​    <strong>因果系统</strong>：是指响应不会超前于激励的系统，没有输入就没有输出。反之为非因果系统。</p><p>​    任何时刻的响应只取决于激励的现在与过去值，而与激励的将来值无关。</p><p>​    如：    $\int_{-\infty}^t x(\tau)d\tau$</p><h3 id="1-3-信号与系统分析概述（了解）"><a href="#1-3-信号与系统分析概述（了解）" class="headerlink" title="1.3 信号与系统分析概述（了解）"></a>1.3 信号与系统分析概述（了解）</h3><ol><li><p>信号与系统的基本内容：</p><p>信号分析、系统分析</p></li><li><p>本课程只限于讨论信号与线性时不变系统的分析。</p></li><li><p>本课程只讨论采用输入－输出关系描述的单输入－单输出系统。</p></li><li><p>本课程只讨论确定信号及其作用于线性时不变系统的响应：</p><p>确定信号：解析法、随机信号：概率统计</p></li><li><p>信号与系统分析可以在时间域中进行，也可以在变换域中进行：</p><p>时间域：物理概念清楚，但计算繁琐</p><p>变换域：简化计算</p></li></ol><h2 id="第2章-连续时间信号与系统的时域分析"><a href="#第2章-连续时间信号与系统的时域分析" class="headerlink" title="第2章 连续时间信号与系统的时域分析"></a>第2章 连续时间信号与系统的时域分析</h2><h3 id="2-1-典型连续时间信号"><a href="#2-1-典型连续时间信号" class="headerlink" title="2.1 典型连续时间信号"></a>2.1 典型连续时间信号</h3><h4 id="2-1-1-复指数信号"><a href="#2-1-1-复指数信号" class="headerlink" title="2.1.1 复指数信号"></a>2.1.1 复指数信号</h4><p>数学表达式：$f(t) &#x3D; Ae^{st}$        复振幅：$A&#x3D;|A|e^{j\theta}$        复频率：$s&#x3D;\sigma+j\omega$</p><p>欧拉公式展开：$Ae^{st}&#x3D;|A|e^{j\theta}e^{(\sigma+j\omega_0)t}&#x3D;|A|e^{\sigma t}cos(\omega_0t+\theta)+j|A|e^{\sigma t}sin(\omega_0t+\theta)$</p><p>根据A和s的取值不同，$Ae^{st}$可用来表示不同的信号：</p><h5 id="1-直流信号"><a href="#1-直流信号" class="headerlink" title="(1) 直流信号"></a>(1) 直流信号</h5><p>​    当A为实数，s &#x3D; 0（即$\sigma &#x3D; 0$，$\omega_0 &#x3D; 0$），此时$Ae^{st}&#x3D;A$成为直流信号。</p><h5 id="2-实指数信号"><a href="#2-实指数信号" class="headerlink" title="(2) 实指数信号"></a>(2) 实指数信号</h5><p>​    当A为实数，$\omega_0&#x3D;0$时，$Ae^{st}&#x3D;Ae^{\sigma t}$单调增长($\sigma&gt;0$)或衰减($\sigma&lt;0$)的实指数信号。</p><h5 id="3-正弦信号（虚指数信号）"><a href="#3-正弦信号（虚指数信号）" class="headerlink" title="(3) 正弦信号（虚指数信号）"></a>(3) 正弦信号（虚指数信号）</h5><p>​    当A为复数，$\sigma&#x3D;0$，则此时$Ae^{st}&#x3D;|A|cos(\omega_0t+\theta)+j|A|sin(\omega_0t+\theta)$，实部为等幅的余弦信号，虚部为等幅的正弦信号。</p><h5 id="4-复指数信号"><a href="#4-复指数信号" class="headerlink" title="(4) 复指数信号"></a>(4) 复指数信号</h5><p>​    一般情况下：$Ae^{st}&#x3D;|A|e^{j\theta}e^{(\sigma+j\omega_0)t}&#x3D;|A|e^{\sigma t}cos(\omega_0t+\theta)+j|A|e^{\sigma t}sin(\omega_0t+\theta)$    </p><p>​    实部为增长(增幅)($\sigma&gt;0$)或衰减($\sigma&lt;0$)的余弦信号，虚部为增长(增幅)($\sigma&gt;0$)或衰减($\sigma&lt;0$)的正弦信号。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
